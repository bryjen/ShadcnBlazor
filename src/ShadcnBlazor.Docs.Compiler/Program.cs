using System.Diagnostics;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using Microsoft.AspNetCore.Components;
using ShadcnBlazor.Shared.Attributes;

const string SnippetsFileName = "Snippets.generated.cs";
const string ApiDocFileName = "ApiDocumentation.generated.cs";

var stopwatch = Stopwatch.StartNew();
var docsDir = Directory.GetCurrentDirectory();

// Parse arguments: --assembly-path <path> or --configuration <Debug|Release>
string? assemblyPath = null;
var argsList = args.ToList();
for (var i = 0; i < argsList.Count; i++)
{
    if (argsList[i] == "--assembly-path" && i + 1 < argsList.Count)
    {
        assemblyPath = argsList[i + 1];
        break;
    }
}

var generatedDir = Path.Combine(docsDir, "Models", "Generated");
var apiOutputPath = Path.Combine(generatedDir, ApiDocFileName);
var snippetsOutputPath = Path.Combine(generatedDir, SnippetsFileName);

Console.WriteLine("ShadcnBlazor.Docs.Compiler");
Console.WriteLine("==========================");

// PART 1: Generate API Documentation
Console.WriteLine("\nGenerating API Documentation...");
GenerateApiDocumentation(assemblyPath, docsDir, apiOutputPath);

// PART 2: Generate Code Snippets
Console.WriteLine("\nGenerating Code Snippets...");
GenerateSnippets(docsDir, snippetsOutputPath);

Console.WriteLine($"\n✓ Generation complete! ({stopwatch.ElapsedMilliseconds} ms)");
return 0;

// ========================================
// API DOCUMENTATION GENERATION
// ========================================

void GenerateApiDocumentation(string? assemblyPathArg, string docsDirPath, string outputPath)
{
    var assemblyPath = assemblyPathArg ?? FindAssemblyPath(docsDirPath);

    if (!File.Exists(assemblyPath))
    {
        Console.WriteLine($"ERROR: Assembly not found at {assemblyPath}");
        Console.WriteLine("Please build ShadcnBlazor.csproj first.");
        Environment.Exit(1);
    }

    var xmlPath = Path.Combine(Path.GetDirectoryName(assemblyPath)!, "ShadcnBlazor.xml");
    if (!File.Exists(xmlPath))
    {
        Console.WriteLine($"WARNING: XML documentation not found at {xmlPath}");
        Console.WriteLine("Continuing without XML documentation...");
    }

    var assembly = Assembly.LoadFrom(assemblyPath);

    Dictionary<string, XElement> xmlDocs = new();
    if (File.Exists(xmlPath))
    {
        var xmlDoc = XDocument.Load(xmlPath);
        xmlDocs = xmlDoc.Descendants("member")
            .Where(m => m.Attribute("name") != null)
            .ToDictionary(m => m.Attribute("name")!.Value, m => m);
    }

    var componentTypes = assembly.GetTypes()
        .Where(t => t.IsPublic && !t.IsAbstract)
        .Where(t => typeof(ComponentBase).IsAssignableFrom(t))
        .Where(t => t.GetCustomAttribute<ComponentMetadataAttribute>() != null)
        .OrderBy(t => t.Name)
        .ToList();

    Console.WriteLine($"Found {componentTypes.Count} components");

    var output = new StringBuilder();
    output.AppendLine("// AUTO-GENERATED - Do not edit manually");
    output.AppendLine("// Generated by ShadcnBlazor.Docs.Compiler");
    output.AppendLine();
    output.AppendLine("using System;");
    output.AppendLine("using System.Collections.Generic;");
    output.AppendLine();
    output.AppendLine("namespace ShadcnBlazor.Docs.Models;");
    output.AppendLine();
    output.AppendLine("[System.CodeDom.Compiler.GeneratedCodeAttribute(\"ShadcnBlazor.Docs.Compiler\", \"0.0.0.0\")]");
    output.AppendLine("public static class ApiDocumentation");
    output.AppendLine("{");

    var allEntries = new List<string>();

    foreach (var type in componentTypes)
    {
        Console.WriteLine($"  Processing {type.Name}...");

        var typeXmlKey = $"T:{type.FullName}";
        var typeSummary = GetXmlElement(xmlDocs, typeXmlKey, "summary");
        var metadata = type.GetCustomAttribute<ComponentMetadataAttribute>();
        if (string.IsNullOrWhiteSpace(typeSummary) && metadata != null)
            typeSummary = metadata.Description;

        var safeName = GetSafeTypeIdentifier(type.Name);
        output.AppendLine($"    public static readonly DocumentedType {safeName} = new()");
        output.AppendLine("    {");
        output.AppendLine($"        Name = \"{type.Name}\",");
        output.AppendLine($"        FullName = \"{EscapeQuotes(type.FullName ?? "")}\",");
        output.AppendLine($"        Summary = @\"{EscapeQuotes(typeSummary)}\",");

        var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(p => p.GetCustomAttribute<ParameterAttribute>() != null)
            .OrderBy(p => p.Name)
            .ToList();

        output.AppendLine("        Properties = new[]");
        output.AppendLine("        {");

        foreach (var prop in properties)
        {
            var propXmlKey = $"P:{type.FullName}.{prop.Name}";
            var summary = GetXmlElement(xmlDocs, propXmlKey, "summary");
            var remarks = GetXmlElement(xmlDocs, propXmlKey, "remarks");

            var categoryAttr = prop.GetCustomAttribute<System.ComponentModel.CategoryAttribute>();
            var defaultValue = GetDefaultValue(prop, type);

            output.AppendLine("            new DocumentedProperty");
            output.AppendLine("            {");
            output.AppendLine($"                Name = \"{prop.Name}\",");
            output.AppendLine($"                Type = \"{GetFriendlyTypeName(prop.PropertyType)}\",");
            output.AppendLine($"                Summary = @\"{EscapeQuotes(summary)}\",");
            output.AppendLine($"                Remarks = @\"{EscapeQuotes(remarks)}\",");
            output.AppendLine($"                Category = \"{EscapeQuotes(categoryAttr?.Category ?? "Common")}\",");
            output.AppendLine($"                DefaultValue = \"{EscapeForRegularString(defaultValue)}\",");
            output.AppendLine("            },");
        }

        output.AppendLine("        },");

        var methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
            .Where(m => !m.IsSpecialName)
            .Where(m => !m.Name.StartsWith("get_") && !m.Name.StartsWith("set_"))
            .OrderBy(m => m.Name)
            .ToList();

        if (methods.Count > 0)
        {
            output.AppendLine("        Methods = new[]");
            output.AppendLine("        {");
        }
        else
        {
            output.AppendLine("        Methods = Array.Empty<DocumentedMethod>(),");
        }

        foreach (var method in methods)
        {
            var methodXmlKey = $"M:{type.FullName}.{method.Name}";
            var summary = GetXmlElement(xmlDocs, methodXmlKey, "summary");
            var returns = GetXmlElement(xmlDocs, methodXmlKey, "returns");

            output.AppendLine("            new DocumentedMethod");
            output.AppendLine("            {");
            output.AppendLine($"                Name = \"{method.Name}\",");
            output.AppendLine($"                Summary = @\"{EscapeQuotes(summary)}\",");
            output.AppendLine($"                ReturnType = \"{GetFriendlyTypeName(method.ReturnType)}\",");
            output.AppendLine($"                Returns = @\"{EscapeQuotes(returns)}\",");
            output.AppendLine("            },");
        }

        if (methods.Count > 0)
        {
            output.AppendLine("        },");
        }

        var events = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(p => IsEventCallback(p.PropertyType))
            .OrderBy(p => p.Name)
            .ToList();

        if (events.Count > 0)
        {
            output.AppendLine("        Events = new[]");
            output.AppendLine("        {");
        }
        else
        {
            output.AppendLine("        Events = Array.Empty<DocumentedEvent>(),");
        }

        foreach (var evt in events)
        {
            var evtXmlKey = $"P:{type.FullName}.{evt.Name}";
            var summary = GetXmlElement(xmlDocs, evtXmlKey, "summary");

            output.AppendLine("            new DocumentedEvent");
            output.AppendLine("            {");
            output.AppendLine($"                Name = \"{evt.Name}\",");
            output.AppendLine($"                Type = \"{GetFriendlyTypeName(evt.PropertyType)}\",");
            output.AppendLine($"                Summary = @\"{EscapeQuotes(summary)}\",");
            output.AppendLine("            },");
        }

        if (events.Count > 0)
        {
            output.AppendLine("        },");
        }
        output.AppendLine("    };");
        output.AppendLine();

        allEntries.Add($"        {{ \"{type.Name}\", {safeName} }}");
    }

    output.AppendLine("    public static IReadOnlyDictionary<string, DocumentedType> All => new Dictionary<string, DocumentedType>");
    output.AppendLine("    {");
    output.AppendLine(string.Join(",\n", allEntries));
    output.AppendLine("    };");
    output.AppendLine("}");

    Directory.CreateDirectory(Path.GetDirectoryName(outputPath)!);
    File.WriteAllText(outputPath, output.ToString());
    Console.WriteLine($"✓ Generated {outputPath}");
}

string FindAssemblyPath(string docsDirPath)
{
    var shadcnDir = Path.GetFullPath(Path.Combine(docsDirPath, "..", "ShadcnBlazor"));
    foreach (var config in new[] { "Debug", "Release" })
    {
        var path = Path.Combine(shadcnDir, "bin", config, "net9.0", "ShadcnBlazor.dll");
        if (File.Exists(path))
            return path;
    }
    return Path.Combine(shadcnDir, "bin", "Debug", "net9.0", "ShadcnBlazor.dll");
}

// ========================================
// CODE SNIPPETS GENERATION
// ========================================

void GenerateSnippets(string docsDirPath, string outputPath)
{
    var componentsPath = Path.Combine(docsDirPath, "Pages", "Components");
    var samplesPath = Path.Combine(docsDirPath, "Pages", "Samples");
    var pseudoComponentsPath = Path.Combine(docsDirPath, "Pages", "PseudoComponents");

    var exampleFiles = new List<string>();
    if (Directory.Exists(componentsPath))
        exampleFiles.AddRange(Directory.EnumerateFiles(componentsPath, "*Example.razor", SearchOption.AllDirectories));
    if (Directory.Exists(samplesPath))
        exampleFiles.AddRange(Directory.EnumerateFiles(samplesPath, "*Example.razor", SearchOption.AllDirectories));
    if (Directory.Exists(pseudoComponentsPath))
        exampleFiles.AddRange(Directory.EnumerateFiles(pseudoComponentsPath, "*Example.razor", SearchOption.AllDirectories));
    exampleFiles = exampleFiles.OrderBy(f => f.Replace("\\", "/"), StringComparer.Ordinal).ToList();

    if (exampleFiles.Count == 0)
    {
        Directory.CreateDirectory(Path.GetDirectoryName(outputPath)!);
        WriteEmptySnippets(outputPath);
        Console.WriteLine("No example files found. Created empty Snippets.generated.cs.");
        return;
    }

    var currentCode = File.Exists(outputPath) ? File.ReadAllText(outputPath) : string.Empty;

    var sb = new StringBuilder();
    sb.AppendLine("//-----------------------------------------------------------------------");
    sb.AppendLine("// AUTO-GENERATED - Do not edit manually");
    sb.AppendLine("// This file is autogenerated by ShadcnBlazor.Docs.Compiler");
    sb.AppendLine("// Any changes will be overwritten on build");
    sb.AppendLine("// <auto-generated />");
    sb.AppendLine("//-----------------------------------------------------------------------");
    sb.AppendLine();
    sb.AppendLine("namespace ShadcnBlazor.Docs.Models");
    sb.AppendLine("{");
    sb.AppendLine("    [System.CodeDom.Compiler.GeneratedCodeAttribute(\"ShadcnBlazor.Docs.Compiler\", \"0.0.0.0\")]");
    sb.AppendLine("    public static partial class Snippets");
    sb.AppendLine("    {");

    foreach (var filePath in exampleFiles)
    {
        var fileName = Path.GetFileNameWithoutExtension(filePath);
        var source = File.ReadAllText(filePath, Encoding.UTF8);
        source = Regex.Replace(source, @"@(namespace|page|layout)\s+.+?\n", string.Empty);
        var escaped = source.Replace("\"", "\"\"").Trim();
        sb.AppendLine($"        public const string {fileName} = @\"{escaped}\";");
        sb.AppendLine();
    }

    sb.AppendLine("    }");
    sb.AppendLine("}");

    var newCode = sb.ToString();

    if (currentCode != newCode)
    {
        Directory.CreateDirectory(Path.GetDirectoryName(outputPath)!);
        File.WriteAllText(outputPath, newCode);
        Console.WriteLine($"✓ Generated snippets for {exampleFiles.Count} examples.");
    }
    else
    {
        File.SetLastWriteTimeUtc(outputPath, DateTime.UtcNow);
        Console.WriteLine("Snippets.generated.cs is up-to-date.");
    }
}

void WriteEmptySnippets(string outputPath)
{
    var minimalContent = """
        //-----------------------------------------------------------------------
        // AUTO-GENERATED - Do not edit manually
        // This file is autogenerated by ShadcnBlazor.Docs.Compiler
        // <auto-generated />
        //-----------------------------------------------------------------------

        namespace ShadcnBlazor.Docs.Models
        {
            [System.CodeDom.Compiler.GeneratedCodeAttribute("ShadcnBlazor.Docs.Compiler", "0.0.0.0")]
            public static partial class Snippets
            {
            }
        }
        """;
    File.WriteAllText(outputPath, minimalContent);
}

// ========================================
// HELPER FUNCTIONS
// ========================================

/// <summary>
/// Converts a type name to a valid C# identifier (e.g. "Select`1" -> "Select").
/// </summary>
string GetSafeTypeIdentifier(string typeName)
{
    var idx = typeName.IndexOf('`');
    return idx >= 0 ? typeName[..idx] : typeName;
}

string GetXmlElement(Dictionary<string, XElement> xmlDocs, string memberKey, string elementName)
{
    if (xmlDocs.TryGetValue(memberKey, out var member))
    {
        return member.Element(elementName)?.Value.Trim() ?? "";
    }
    return "";
}

string EscapeQuotes(string text)
{
    return text?.Replace("\"", "\"\"") ?? "";
}

/// <summary>
/// Escapes for use inside a regular C# string literal "..." (not verbatim).
/// Avoids generating """ which triggers raw string literal in C# 11+.
/// </summary>
string EscapeForRegularString(string text)
{
    if (text is null) return "";
    return text.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\r", "\\r").Replace("\n", "\\n");
}

string GetFriendlyTypeName(Type type)
{
    if (type.IsGenericType)
    {
        var genericName = type.Name.Substring(0, type.Name.IndexOf('`'));
        var genericArgs = string.Join(", ", type.GetGenericArguments().Select(GetFriendlyTypeName));
        return $"{genericName}<{genericArgs}>";
    }

    return type.Name switch
    {
        "Int32" => "int",
        "String" => "string",
        "Boolean" => "bool",
        "Double" => "double",
        "Decimal" => "decimal",
        "Single" => "float",
        "Int64" => "long",
        "Void" => "void",
        _ => type.Name
    };
}

string GetDefaultValue(PropertyInfo prop, Type declaringType)
{
    try
    {
        var instance = Activator.CreateInstance(declaringType);
        var value = prop.GetValue(instance);

        if (value == null)
            return "null";

        if (prop.PropertyType.IsEnum)
            return $"{prop.PropertyType.Name}.{value}";

        if (value is bool b)
            return b ? "true" : "false";

        if (value is string s)
            return $"\"{EscapeQuotes(s)}\"";

        return value.ToString() ?? "null";
    }
    catch
    {
        return prop.PropertyType.IsValueType ? "default" : "null";
    }
}

bool IsEventCallback(Type type)
{
    if (!type.IsGenericType)
        return type.Name == "EventCallback";

    var genericDef = type.GetGenericTypeDefinition();
    return genericDef.Name.StartsWith("EventCallback");
}
