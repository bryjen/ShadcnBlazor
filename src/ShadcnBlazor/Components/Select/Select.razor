@typeparam T
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using ShadcnBlazor.Components.Popover
@using ShadcnBlazor.Components.Popover.Models
@inherits ShadcnComponentBase
@implements IAsyncDisposable
@inject IJSRuntime JsRuntime

<Popover Open="@_open"
         OpenChanged="HandleOpenChanged"
         CloseOnOutsideClick="true"
         AnchorOrigin="PopoverPlacement.BottomLeft"
         TransformOrigin="PopoverPlacement.TopLeft"
         WidthMode="@(PopoverFitContent ? PopoverWidthMode.Adaptive : PopoverWidthMode.Relative)"
         AnchorClass="min-w-full max-w-full w-full">
    <Anchor>
        <button id="@_triggerId"
                type="button"
                role="combobox"
                aria-expanded="@_open"
                aria-haspopup="listbox"
                aria-controls="@_listboxId"
                aria-activedescendant="@GetActiveDescendant()"
                aria-disabled="@Disabled"
                data-size="@Size.ToString().ToLower()"
                class="@GetTriggerClass()"
                disabled="@Disabled"
                @onclick="ToggleOpen"
                @onkeydown="HandleTriggerKeyDown"
                @attributes="AdditionalAttributes">
            <span class="truncate">@GetDisplayText()</span>
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="@(_open ? "rotate-180" : "") transition-transform duration-200">
                <path d="m6 9 6 6 6-6" />
            </svg>
        </button>
    </Anchor>
    <ChildContent>
        <div class="@GetContentClass() rounded-lg border border-input bg-popover text-popover-foreground shadow-lg p-1 min-w-[8rem]">
            @if (!string.IsNullOrEmpty(Label))
            {
                <div class="px-2 py-1.5 text-xs font-medium text-muted-foreground">@Label</div>
            }
            <div id="@_listboxId"
                 role="listbox"
                 aria-labelledby="@_triggerId"
                 class="max-h-[var(--radix-select-content-available-height)] overflow-y-auto overflow-x-hidden">
                @{
                    var options = GetOptions();
                }
                @for (var i = 0; i < options.Count; i++)
                {
                    var optionIndex = i;
                    var item = options[optionIndex];
                    var isSelected = IsSelected(item.Value);
                    var isActive = _activeIndex == optionIndex;
                    <button type="button"
                            id="@GetOptionId(optionIndex)"
                            role="option"
                            tabindex="-1"
                            aria-selected="@isSelected"
                            class="@GetOptionClass(isSelected, isActive)"
                            @onpointerdown="() => SelectOptionAtIndexAsync(optionIndex)"
                            @onpointerdown:preventDefault="true"
                            @onpointerdown:stopPropagation="true">
                        @if (isSelected)
                        {
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-4 shrink-0">
                                <polyline points="20 6 9 17 4 12" />
                            </svg>
                        }
                        <span class="@(PopoverFitContent ? "whitespace-nowrap" : "truncate")">@item.DisplayText</span>
                    </button>
                }
            </div>
        </div>
    </ChildContent>
</Popover>

@code {
    [Parameter] public string? Label { get; set; }
    [Parameter] public T? Value { get; set; }
    [Parameter] public EventCallback<T?> ValueChanged { get; set; }
    [Parameter, EditorRequired] public required IEnumerable<SelectOption<T>> Items { get; set; }
    [Parameter] public string Placeholder { get; set; } = "Select...";
    [Parameter] public Size Size { get; set; } = Size.Md;
    /// <summary>
    /// When true, the popover expands to fit the width of its option content instead of matching the trigger width.
    /// </summary>
    [Parameter] public bool PopoverFitContent { get; set; }
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public string TriggerClass { get; set; } = string.Empty;

    private readonly string _triggerId = $"select-trigger-{Guid.NewGuid():N}";
    private readonly string _listboxId = $"select-listbox-{Guid.NewGuid():N}";
    private bool _open;
    private bool _suppressNextToggle;
    private int? _activeIndex;
    private string? _pendingScrollOptionId;
    private IJSObjectReference? _module;

    private string GetContentClass()
    {
        return PopoverFitContent
            ? "w-max"
            : "w-[var(--popover-width)]";
    }

    private string GetTriggerClass()
    {
        var baseClasses = "flex w-full items-center justify-between gap-2 rounded-md border border-input bg-input/30 shadow-xs transition-colors hover:bg-input/50 focus-visible:outline-none focus-visible:brightness-110 disabled:cursor-not-allowed disabled:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0";
        var sizeClasses = Size switch
        {
            Size.Sm => "h-6 px-1.75 py-0.75 text-[0.6rem]",
            Size.Md => "h-7 px-2.5 py-1 text-sm",
            Size.Lg => "h-8 px-2.75 py-1.25 text-base md:text-sm",
            _ => "h-7 px-2.5 py-1 text-sm",
        };
        return MergeCss(baseClasses, sizeClasses, TriggerClass);
    }

    private string GetOptionClass(bool isSelected, bool isActive)
    {
        var selectedClasses = isSelected
            ? "bg-primary text-primary-foreground"
            : "hover:bg-accent hover:text-accent-foreground";
        var activeClasses = isActive ? "brightness-110" : string.Empty;
        return MergeCss(selectedClasses, activeClasses, "flex w-full cursor-pointer items-center gap-2 rounded-md px-2 py-1.5 text-sm outline-none focus-visible:outline-none focus-visible:brightness-110 transition-colors");
    }

    private string GetDisplayText()
    {
        if (Value is null)
            return Placeholder;

        var option = GetOptions().FirstOrDefault(o => EqualityComparer<T>.Default.Equals(o.Value, Value));
        return option.DisplayText;
    }

    private bool IsSelected(T? value)
    {
        if (value is null && Value is null) return true;
        if (value is null || Value is null) return false;
        return EqualityComparer<T>.Default.Equals(value, Value);
    }

    private string? GetActiveDescendant()
    {
        if (!_open || _activeIndex is null)
            return null;

        return GetOptionId(_activeIndex.Value);
    }

    private string GetOptionId(int index) => $"{_listboxId}-option-{index}";

    private List<SelectOption<T>> GetOptions() => [.. Items];

    private int? GetSelectedIndex(List<SelectOption<T>> options)
    {
        for (var i = 0; i < options.Count; i++)
        {
            if (EqualityComparer<T>.Default.Equals(options[i].Value, Value))
                return i;
        }

        return null;
    }

    private void SetActiveIndex(int? index)
    {
        _activeIndex = index;
        if (_open && index is not null)
        {
            _pendingScrollOptionId = GetOptionId(index.Value);
        }
    }

    private void EnsureActiveOnOpen()
    {
        var options = GetOptions();
        if (options.Count == 0)
        {
            SetActiveIndex(null);
            return;
        }

        var selectedIndex = GetSelectedIndex(options);
        SetActiveIndex(selectedIndex ?? 0);
    }

    private Task HandleOpenChanged(bool open)
    {
        _open = open;
        if (_open)
        {
            EnsureActiveOnOpen();
        }

        return Task.CompletedTask;
    }

    private Task ToggleOpen()
    {
        if (Disabled)
            return Task.CompletedTask;

        if (_suppressNextToggle)
        {
            _suppressNextToggle = false;
            return Task.CompletedTask;
        }

        _open = !_open;
        if (_open)
        {
            EnsureActiveOnOpen();
        }

        return Task.CompletedTask;
    }

    private async Task HandleTriggerKeyDown(KeyboardEventArgs e)
    {
        if (Disabled)
            return;

        var options = GetOptions();
        if (options.Count == 0)
            return;

        switch (e.Key)
        {
            case "ArrowDown":
                if (!_open)
                {
                    _open = true;
                    EnsureActiveOnOpen();
                }
                else
                {
                    var start = _activeIndex ?? -1;
                    SetActiveIndex((start + 1) % options.Count);
                }
                break;
            case "ArrowUp":
                if (!_open)
                {
                    _open = true;
                    EnsureActiveOnOpen();
                }
                else
                {
                    var start = _activeIndex ?? 0;
                    SetActiveIndex((start - 1 + options.Count) % options.Count);
                }
                break;
            case "Home":
                if (!_open)
                    _open = true;
                SetActiveIndex(0);
                break;
            case "End":
                if (!_open)
                    _open = true;
                SetActiveIndex(options.Count - 1);
                break;
            case "Enter":
            case " ":
                if (!_open)
                {
                    _open = true;
                    EnsureActiveOnOpen();
                }
                else if (_activeIndex is not null)
                {
                    await SelectOptionAtIndexAsync(_activeIndex.Value);
                }
                break;
            case "Escape":
                _open = false;
                break;
            case "Tab":
                _open = false;
                break;
        }
    }

    private async Task SelectOptionAtIndexAsync(int index)
    {
        var options = GetOptions();
        if (index < 0 || index >= options.Count)
            return;

        Value = options[index].Value;
        SetActiveIndex(index);
        await ValueChanged.InvokeAsync(Value);
        _suppressNextToggle = true;
        _open = false;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_open && !string.IsNullOrEmpty(_pendingScrollOptionId))
        {
            await EnsureModuleAsync();
            if (_module is not null)
            {
                await _module.InvokeVoidAsync("ensureOptionVisible", _listboxId, _pendingScrollOptionId);
            }
            _pendingScrollOptionId = null;
        }
    }

    private async Task EnsureModuleAsync()
    {
        if (_module is not null)
            return;

        _module = await JsRuntime.InvokeAsync<IJSObjectReference>(
            "import",
            "/ShadcnBlazor/_content/ShadcnBlazor/Components/Select/Select.razor.js");
    }

    public async ValueTask DisposeAsync()
    {
        if (_module is not null)
        {
            await _module.DisposeAsync();
            _module = null;
        }
    }
}






