@namespace ShadcnBlazor.Components.Accordion
@inherits ShadcnComponentBase

<CascadingValue Value="_itemContext">
    <div
        data-slot="accordion-item"
        class="@GetClass()"
        @attributes="GetAttributes()">
        @ChildContent
    </div>
</CascadingValue>

@code {
    [CascadingParameter]
    private Accordion.AccordionContext? AccordionContext { get; set; }

    /// <summary>
    /// A unique value that identifies this item. Used to control which item is open and for two-way binding.
    /// </summary>
    [Parameter]
    public required string Value { get; set; }

    /// <summary>
    /// When true, the item cannot be expanded or collapsed. The trigger appears disabled and does not respond to clicks.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }

    /// <summary>
    /// The content of the item, typically an <see cref="AccordionTrigger"/> followed by <see cref="AccordionContent"/>.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    private AccordionItemContext _itemContext = null!;
    private readonly string _elementId = $"accordion-{Guid.NewGuid():N}";

    protected override void OnInitialized()
    {
        if (AccordionContext is null)
            throw new InvalidOperationException("AccordionItem must be used inside an Accordion.");

        _itemContext = new AccordionItemContext(AccordionContext, Value, Disabled, $"{_elementId}-trigger", $"{_elementId}-content");
    }

    protected override void OnParametersSet()
    {
        _itemContext = new AccordionItemContext(AccordionContext!, Value, Disabled, $"{_elementId}-trigger", $"{_elementId}-content");
    }

    private string GetClass()
    {
        var baseClasses = "border-b border-border";
        return MergeCss(baseClasses, Class);
    }

    private IReadOnlyDictionary<string, object>? GetAttributes()
    {
        var merged = new Dictionary<string, object>(StringComparer.Ordinal)
        {
            ["role"] = "region",
            ["aria-labelledby"] = _itemContext.TriggerId
        };
        if (AdditionalAttributes is not null)
            foreach (var kv in AdditionalAttributes)
                merged[kv.Key] = kv.Value;
        return merged;
    }

    internal sealed class AccordionItemContext
    {
        private readonly Accordion.AccordionContext _accordion;

        public AccordionItemContext(Accordion.AccordionContext accordion, string value, bool disabled, string triggerId, string contentId)
        {
            _accordion = accordion;
            Value = value;
            Disabled = disabled;
            TriggerId = triggerId;
            ContentId = contentId;
        }

        public string Value { get; }

        public bool Disabled { get; }

        public string TriggerId { get; }

        public string ContentId { get; }

        public bool IsOpen => _accordion.IsItemOpen(Value);

        public Task ToggleAsync() => _accordion.ToggleItemAsync(Value);
    }
}
